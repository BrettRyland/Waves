#pragma once
///@file

#include <memory>
#include <vector>
#include <array>

/// Surface mesh namespace for the non-Qt version
namespace Waves::Mesh {
	/// A structure for holding vertex and element buffer objects for the shader program.
	struct surface_mesh {
		GLuint vertex_buffer, ///< The vertex buffer handle
			element_buffer; ///< The element buffer handle
		GLsizei vertex_count, ///< The number of elements in the vertex buffer
			element_count; ///< The number of elements in the element buffer
		std::vector<std::array<unsigned int, 3>> adjacency_information; ///< Vertex adjacency information (right, above, above right)
	};

	/// The structure of each vertex element.
	struct surface_vertex {
		GLfloat position[4]; ///< Position in R^3 in homogeneous coordinates
		GLfloat normal[4]{ 0.0f, 0.0f, 1.0f, 0.0f }; ///< Unit normal in R^3 in homogeneous coordinates
		GLfloat shininess{ 20.0f }; ///< Shininess of the vertex
		GLfloat specular[4]{ 0.1f, 0.3f, 0.7f, 1.0f }; ///< Specularity of the vertex
		/// Constructor
		surface_vertex(GLfloat x, GLfloat y) : position{ x, y, 0.0f, 1.0f } {};
		surface_vertex() = default; ///< @overload
	};

	/// Pass the mesh generated by init_surface_mesh to the shader program.
	void init_mesh(surface_mesh& out_mesh, const std::vector<surface_vertex>& vertex_data, GLsizei vertex_count, const std::vector<GLuint>& element_data, GLsizei element_count, GLenum hint);
	/// Generate a surface mesh (later assigned to g_resoures.surface_vertex_array).
	std::vector<surface_vertex> init_surface_mesh(surface_mesh& out_mesh);
	/// Update the surface_vertex data based on the updated values of the integrator Waves::g_waves.
	void calculate_surface_vertex(std::vector<surface_vertex>& vertex_data, const std::vector<std::array<unsigned int, 3>>& adjacency_information);
	/// Pass the updated surface_vertex data to the shader program.
	void update_surface_mesh(const surface_mesh& mesh, std::vector<surface_vertex>& vertex_data);
}
