#pragma once

#include <memory>
#include <vector>
#include <array>

namespace Waves::Mesh {
	// A structure for holding vertex and element buffer objects for the shader program.
	struct surface_mesh {
		GLuint vertex_buffer, element_buffer;
		GLsizei vertex_count, element_count;
		std::vector<std::array<unsigned int, 3>> adjacency_information;
	};

	// The structure of each vertex element.
	struct surface_vertex {
		GLfloat position[4];
		GLfloat normal[4]{0.0f,0.0f,1.0f,0.0f};
		GLfloat shininess{0.8f};
		GLubyte specular[4]{255,255,255,255};
		surface_vertex() = default;
		surface_vertex(GLfloat x, GLfloat y) : position{x,y,0.0f,1.0f} {};
	};

	// Pass the mesh generated by init_surface_mesh to the shader program.
	void init_mesh(surface_mesh& out_mesh, const std::vector<surface_vertex>& vertex_data, GLsizei vertex_count, const std::vector<GLuint>& element_data, GLsizei element_count, GLenum hint);
	// Generate a surface mesh (later assigned to g_resoures.surface_vertex_array).
	std::vector<surface_vertex> init_surface_mesh(surface_mesh& out_mesh);
	// Update the surface_vertex data based on the updated values of the integrator Waves::g_waves.
	void calculate_surface_vertex(std::vector<surface_vertex>& vertex_data, const std::vector<std::array<unsigned int, 3>>& adjacency_information);
	// Pass the updated surface_vertex data to the shader program.
	void update_surface_mesh(const surface_mesh& mesh, std::vector<surface_vertex>& vertex_data);
}
