//FIXME: all the pointers and horrid mallocs here should be redone in terms of std::unique_ptr

#include <gl/glew.h>
#include <GL/freeglut.h>
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <memory>
#include "mesh.h"
#include "integrator.h"

using glm::vec3;
using glm::vec4;
using glm::mat4;

// Pass the mesh generated by init_surface_mesh to the shader program.
void Waves::Mesh::init_mesh(Waves::Mesh::surface_mesh& out_mesh, const std::vector<Waves::Mesh::surface_vertex>& vertex_data, GLsizei vertex_count, const std::vector<GLuint>& element_data, GLsizei element_count, GLenum hint)
{
	glGenBuffers(1, &(out_mesh.vertex_buffer));
	glGenBuffers(1, &(out_mesh.element_buffer));
	out_mesh.vertex_count = vertex_count;
	out_mesh.element_count = element_count;

	glBindBuffer(GL_ARRAY_BUFFER, out_mesh.vertex_buffer);
	glBufferData(
		GL_ARRAY_BUFFER,
		vertex_count * sizeof(Waves::Mesh::surface_vertex),
		vertex_data.data(),
		hint
	);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, out_mesh.element_buffer);
	glBufferData(
		GL_ELEMENT_ARRAY_BUFFER,
		element_count * sizeof(GLuint),
		element_data.data(),
		GL_STATIC_DRAW // The element_data doesn't get updated, so it can be static.
	);
}

// Generate a surface mesh (later assigned to g_resoures.surface_vertex_array).
std::vector<Waves::Mesh::surface_vertex> Waves::Mesh::init_surface_mesh(Waves::Mesh::surface_mesh& out_mesh)
{
	// Calculate vertex and element data and then call init_mesh with these.
	// The element data can then be thrown away, but the vertex data is needed later so we can update it in update_surface_mesh.
	std::size_t vertex_count = (g_waves.domain_size_x + 1)*(g_waves.domain_size_y + 1);
	std::size_t element_count = 6 * g_waves.domain_size_x*g_waves.domain_size_y;
	std::vector<Waves::Mesh::surface_vertex> vertex_data(vertex_count);
	std::vector<GLuint> element_data;
	element_data.reserve(element_count);
	int s, t, i;
	GLuint index;
	GLfloat scale{ 5.0f };

	// Assign the static components of the position, normal, shininess and specular values.
	// The non-static components (position[2] and normal[0-2]) are assigned in calculate_surface_vertex().
	for (t = 0, i = 0; t < g_waves.domain_size_y + 1; ++t)
		for (s = 0; s < g_waves.domain_size_x + 1; ++s, ++i) {
			vertex_data[i].position[0] = scale * (2.0f * s - g_waves.domain_size_x) / g_waves.domain_size_x;
			vertex_data[i].position[1] = scale * (2.0f * t - g_waves.domain_size_y) / g_waves.domain_size_y;
			vertex_data[i].position[3] = 1.0f;
			vertex_data[i].normal[3] = 0.0f;
			vertex_data[i].shininess = 0.0f;
			vertex_data[i].specular[0] = 0.0f;
			vertex_data[i].specular[1] = 0.0f;
			vertex_data[i].specular[2] = 0.0f;
			vertex_data[i].specular[3] = 0.0f;
		}

	// Calculate surface heights and normals.
	calculate_surface_vertex(vertex_data);

	// Calculate the element indices.
	for (t = 0, index = 0; t < g_waves.domain_size_y; ++t, ++index)
		for (s = 0; s < g_waves.domain_size_x; ++s, ++index) {
			element_data.emplace_back(index);
			element_data.emplace_back(index + 1);
			element_data.emplace_back(index + g_waves.domain_size_x + 1);
			element_data.emplace_back(index + 1);
			element_data.emplace_back(index + g_waves.domain_size_x + 2);
			element_data.emplace_back(index + g_waves.domain_size_x + 1);
		}

	// Pass the vertex and element data to init_mesh with the DYNAMIC flag as this data will change frequently.
	init_mesh(out_mesh, vertex_data, vertex_count, element_data, element_count, GL_DYNAMIC_DRAW);

	return vertex_data;
}

// Update the surface_vertex data based on the updated values of the integrator Waves::g_waves.
void Waves::Mesh::calculate_surface_vertex(std::vector<Waves::Mesh::surface_vertex>& vertex_data)
{
	auto it_U = g_waves.cells.begin();
	auto it_vd = vertex_data.begin();
	int t, s;
	// Calculate positions
	for (t = 0; t < g_waves.domain_size_y; ++t, ++it_vd) {
		for (s = 0; s < g_waves.domain_size_x; ++s, ++it_vd, ++it_U)
			(*it_vd).position[2] = (*it_U).U[0];
		// Last column
		(*it_vd).position[2] = (*(it_vd - g_waves.domain_size_x)).position[2];
	}
	// Last row
	for (auto it = vertex_data.begin(); it != vertex_data.begin() + g_waves.domain_size_x + 1; ++it, ++it_vd)
		(*it_vd).position[2] = (*it).position[2];
	// Calculate normals
	vec3 u, v;
	for (t = 0, it_vd = vertex_data.begin(); t < g_waves.domain_size_y; ++t, ++it_vd) {
		for (s = 0; s < g_waves.domain_size_x; ++s, ++it_vd) {
			u = { (*(it_vd + 1)).position[0] - (*it_vd).position[0],(*(it_vd + 1)).position[1] - (*it_vd).position[1], (*(it_vd + 1)).position[2] - (*it_vd).position[2] };
			v = { (*(it_vd + g_waves.domain_size_x + 1)).position[0] - (*it_vd).position[0],(*(it_vd + g_waves.domain_size_x + 1)).position[1] - (*it_vd).position[1], (*(it_vd + g_waves.domain_size_x + 1)).position[2] - (*it_vd).position[2] };
			std::memcpy(&(*it_vd).normal[0], glm::value_ptr(glm::normalize(glm::cross(u, v))), 3 * sizeof(GLfloat));
		}
		// Last column
		std::memcpy(&(*it_vd).normal[0], &(*(it_vd - g_waves.domain_size_x)).normal[0], 3 * sizeof(GLfloat));
	}
	// Last row
	for (auto it = vertex_data.begin(); it != vertex_data.begin() + g_waves.domain_size_x + 1; ++it, ++it_vd)
		std::memcpy(&(*it_vd).normal[0], &(*it).normal[0], 3 * sizeof(GLfloat));
}

// Pass the updated surface_vertex data to the shader program.
void Waves::Mesh::update_surface_mesh(const Waves::Mesh::surface_mesh& mesh, std::vector<Waves::Mesh::surface_vertex>& vertex_data)
{
	// Update the surface_vertex buffer.
	calculate_surface_vertex(vertex_data);
	glBindBuffer(GL_ARRAY_BUFFER, mesh.vertex_buffer);
	glBufferData(GL_ARRAY_BUFFER, mesh.vertex_count * sizeof(Waves::Mesh::surface_vertex), vertex_data.data(), GL_DYNAMIC_DRAW);
}
