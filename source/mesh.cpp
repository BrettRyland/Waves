//FIXME: all the pointers and horrid mallocs here should be redone in terms of std::unique_ptr

#include <gl/glew.h>
#include <GL/freeglut.h>
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <memory>
#include <limits>
#include <algorithm>
#include <vector>
#include <array>
#include "mesh.h"
#include "integrator.h"

using glm::vec3;
using glm::vec4;
using glm::mat4;
const unsigned int missing_index = std::numeric_limits<unsigned int>::max();

namespace Waves::Mesh {
	// Pass the mesh generated by init_surface_mesh to the shader program.
	void init_mesh(surface_mesh& out_mesh, const std::vector<surface_vertex>& vertex_data, GLsizei vertex_count, const std::vector<GLuint>& element_data, GLsizei element_count, GLenum hint)
	{
		glGenBuffers(1, &(out_mesh.vertex_buffer));
		glGenBuffers(1, &(out_mesh.element_buffer));
		out_mesh.vertex_count = vertex_count;
		out_mesh.element_count = element_count;

		glBindBuffer(GL_ARRAY_BUFFER, out_mesh.vertex_buffer);
		glBufferData(
			GL_ARRAY_BUFFER,
			vertex_count * sizeof(Mesh::surface_vertex),
			vertex_data.data(),
			hint
		);

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, out_mesh.element_buffer);
		glBufferData(
			GL_ELEMENT_ARRAY_BUFFER,
			element_count * sizeof(GLuint),
			element_data.data(),
			GL_STATIC_DRAW // The element_data only gets updated when we change the boundary conditions, so it can be static.
		);
	}

	// Generate a surface mesh (later assigned to g_resoures.surface_vertex_array).
	std::vector<surface_vertex> init_surface_mesh(surface_mesh& out_mesh)
	{
		// Calculate vertex and element data and then call init_mesh with these.
		// The element data can then be thrown away, but the vertex data is needed later so we can update it in update_surface_mesh.
		unsigned int vertex_count = g_waves.cells.size();
		std::vector<surface_vertex> vertex_data(vertex_count); // under estimate, but it will grow as needed.
		std::vector<GLuint> element_data;
		element_data.reserve(6 * g_waves.cells.size());
		out_mesh.adjacency_information.clear();
		int s, t, i;
		GLuint index;
		GLfloat scale{ 5.0f };

		// Assign the components of the position, normal, shininess and specular values, adding in extra vertices as necessary.
		// The non-static components (position[2] and normal[0-2]) are reassigned in calculate_surface_vertex().
		// FIXME: We should not draw cells for Dirichlet_right and Neumann_right.
		// FIXME: We need to detect periodicity and draw extra cells instead.
		for (unsigned int c = 0; c < g_waves.cells.size(); ++c) {
			vertex_data[c] = { static_cast<GLfloat>(g_waves.position_information[c][0]), static_cast<GLfloat>(g_waves.position_information[c][1]) };
			if (g_waves.adjacency_information[c][1] != missing_index && g_waves.adjacency_information[c][3] != missing_index) { // right and top edges are there
				out_mesh.adjacency_information.emplace_back(std::array<unsigned int, 2>{static_cast<GLuint>(g_waves.adjacency_information[c][1]), static_cast<GLuint>(g_waves.adjacency_information[c][3])});
				if (g_waves.adjacency_information[g_waves.adjacency_information[c][1]][3] != missing_index) { // top right is also there
					element_data.insert(element_data.end(), { c, g_waves.adjacency_information[c][1], g_waves.adjacency_information[c][3], g_waves.adjacency_information[c][1], g_waves.adjacency_information[g_waves.adjacency_information[c][1]][3], g_waves.adjacency_information[c][3] });
				}
				else { // top right is missing
					vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0] + g_waves.step_size_x),static_cast<GLfloat>(g_waves.position_information[c][1] + g_waves.step_size_y) });
					element_data.insert(element_data.end(), { c, g_waves.adjacency_information[c][1], g_waves.adjacency_information[c][3], g_waves.adjacency_information[c][1], vertex_count, g_waves.adjacency_information[c][3] });
					++vertex_count;
				}
			}
			else if (g_waves.adjacency_information[c][3] == missing_index && g_waves.adjacency_information[c][1] == missing_index) { // both edges missing (and hence top right corner missing too since it is disconnected)
				vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0] + g_waves.step_size_x),static_cast<GLfloat>(g_waves.position_information[c][1]) });
				vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0]),static_cast<GLfloat>(g_waves.position_information[c][1] + g_waves.step_size_y) });
				vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0] + g_waves.step_size_x),static_cast<GLfloat>(g_waves.position_information[c][1] + g_waves.step_size_y) });
				element_data.insert(element_data.end(), { c, vertex_count, vertex_count + 1, vertex_count, vertex_count + 2, vertex_count + 1 });
				out_mesh.adjacency_information.emplace_back(std::array<unsigned int, 2>{vertex_count, vertex_count + 1});
				vertex_count += 3;
			}
			else if ((g_waves.adjacency_information[c][1] == missing_index) && (g_waves.adjacency_information[c][3] != missing_index)) { // right is missing, but top is there
				vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0] + g_waves.step_size_x),static_cast<GLfloat>(g_waves.position_information[c][1]) });
				out_mesh.adjacency_information.emplace_back(std::array<unsigned int, 2>{ {vertex_count, g_waves.adjacency_information[c][3]}});
				if (g_waves.adjacency_information[g_waves.adjacency_information[c][3]][1] == missing_index) { // top right is missing
					vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0] + g_waves.step_size_x),static_cast<GLfloat>(g_waves.position_information[c][1] + g_waves.step_size_y) });
					element_data.insert(element_data.end(), { c, vertex_count, g_waves.adjacency_information[c][3], vertex_count, vertex_count + 1, g_waves.adjacency_information[c][3] });
					vertex_count += 2;
				}
				else { // top right is there
					element_data.insert(element_data.end(), { c, vertex_count, g_waves.adjacency_information[c][3], vertex_count, g_waves.adjacency_information[g_waves.adjacency_information[c][3]][1], g_waves.adjacency_information[c][3] });
					++vertex_count;
				}
			}
			else if ((g_waves.adjacency_information[c][1] != missing_index) && (g_waves.adjacency_information[c][3] == missing_index)) { // top is missing, but right is there
				vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0]),static_cast<GLfloat>(g_waves.position_information[c][1] + g_waves.step_size_y) });
				out_mesh.adjacency_information.emplace_back(std::array<unsigned int, 2>{g_waves.adjacency_information[c][1], vertex_count});
				if (g_waves.adjacency_information[g_waves.adjacency_information[c][1]][3] == missing_index) { // top right is missing
					vertex_data.emplace_back(surface_vertex{ static_cast<GLfloat>(g_waves.position_information[c][0] + g_waves.step_size_x),static_cast<GLfloat>(g_waves.position_information[c][1] + g_waves.step_size_y) });
					element_data.insert(element_data.end(), { c, g_waves.adjacency_information[c][1], vertex_count, g_waves.adjacency_information[c][1], vertex_count + 1, vertex_count });
					vertex_count += 2;
				}
				else { // top right is there
					element_data.insert(element_data.end(), { c, g_waves.adjacency_information[c][1], vertex_count, g_waves.adjacency_information[c][1], g_waves.adjacency_information[g_waves.adjacency_information[c][1]][3], vertex_count });
					++vertex_count;
				}
			}
			else {
				throw std::runtime_error("Oops, we shouldn't be here.");
			}
		}

		// Calculate surface heights and normals.
		calculate_surface_vertex(vertex_data, out_mesh.adjacency_information);

		// Pass the vertex and element data to init_mesh with the DYNAMIC flag as this data will change frequently.
		init_mesh(out_mesh, vertex_data, vertex_count, element_data, element_data.size(), GL_DYNAMIC_DRAW);

		return vertex_data;
	}

	// Update the surface_vertex data based on the updated values of the integrator g_waves.
	void calculate_surface_vertex(std::vector<surface_vertex>& vertex_data, const std::vector<std::array<unsigned int, 2>>& adjacency_information)
	{
		// Copy heights
#pragma omp parallel for
		for (int c = 0; c < g_waves.cells.size(); ++c)
			vertex_data[c].position[2] = g_waves.cells[c].U[0];

		// Calculate normals
#pragma omp parallel for
		for (int c = 0; c < g_waves.cells.size(); ++c) {
			vec3 u = { vertex_data[adjacency_information[c][0]].position[0] - vertex_data[c].position[0],vertex_data[adjacency_information[c][0]].position[1] - vertex_data[c].position[1], vertex_data[adjacency_information[c][0]].position[2] - vertex_data[c].position[2] };
			vec3 v = { vertex_data[adjacency_information[c][1]].position[0] - vertex_data[c].position[0],vertex_data[adjacency_information[c][1]].position[1] - vertex_data[c].position[1], vertex_data[adjacency_information[c][1]].position[2] - vertex_data[c].position[2] };
			std::memcpy(&vertex_data[c].normal[0], glm::value_ptr(glm::normalize(glm::cross(u, v))), 3 * sizeof(GLfloat));
		}
	}

	// Pass the updated surface_vertex data to the shader program.
	void update_surface_mesh(const surface_mesh& mesh, std::vector<surface_vertex>& vertex_data)
	{
		// Update the surface_vertex buffer.
		calculate_surface_vertex(vertex_data, mesh.adjacency_information);
		glBindBuffer(GL_ARRAY_BUFFER, mesh.vertex_buffer);
		glBufferData(GL_ARRAY_BUFFER, mesh.vertex_count * sizeof(Mesh::surface_vertex), vertex_data.data(), GL_DYNAMIC_DRAW);
	}
}